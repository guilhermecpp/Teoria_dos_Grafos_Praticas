Algoritmo 1:
    * Marque todos os vértices não visitados. Crie um conjunto de todos os 
        vértices não visitados.
    * Atribua valor de distância zero ao vértice de origem e valor de distância 
        infinita a todos os outros vértices.
    * Defina o vértice de origem como vértice atual
    * Para o vértice atual, considere todos os seus filhos não visitados e 
        calcule suas distâncias provisórias através da corrente. (distância da 
        corrente + peso da aresta correspondente) Compare a distância 
        recém-calculada com o valor atribuído atual (pode ser infinito para 
        alguns vértices) e atribua o menor.
    * Depois de considerar todos os filhos não visitados do vértice atual, 
        marque o atual como visitado e remova-o do conjunto não visitado.
    * Da mesma forma, continue para todos os vértices até que todos os nós sejam visitados.

Código 1:
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
 
class Pair
{
    int first, second;
 
    public Pair(int first, int second)
    {
        this.first = first;
        this.second = second;
    }
}
 
class GFG{
 
static final int infi = 1000000000;
 
// Class of the node
static class Node
{
    int vertexNumber;
 
    // Adjacency list that shows the
    // vertexNumber of child vertex
    // and the weight of the edge
    List<Pair> children;
 
    Node(int vertexNumber)
    {
        this.vertexNumber = vertexNumber;
        children = new ArrayList<>();
    }
 
    // Function to add the child for
    // the given node
    void add_child(int vNumber, int length)
    {
        Pair p = new Pair(vNumber, length);
        children.add(p);
    }
}
 
// Function to find the distance of
// the node from the given source
// vertex to the destination vertex
static int[] dijkstraDist(List<Node> g,
                          int s, int[] path)
{
     
    // Stores distance of each
    // vertex from source vertex
    int[] dist = new int[g.size()];
 
    // Boolean array that shows
    // whether the vertex 'i'
    // is visited or not
    boolean[] visited = new boolean[g.size()];
    for(int i = 0; i < g.size(); i++)
    {
        visited[i] = false;
        path[i] = -1;
        dist[i] = infi;
    }
    dist[s] = 0;
    path[s] = -1;
    int current = s;
 
    // Set of vertices that has
    // a parent (one or more)
    // marked as visited
    Set<Integer> sett = new HashSet<>();
    while (true)
    {
         
        // Mark current as visited
        visited[current] = true;
        for(int i = 0;
                i < g.get(current).children.size();
                i++)
        {
            int v = g.get(current).children.get(i).first;
             
            if (visited[v])
                continue;
 
            // Inserting into the
            // visited vertex
            sett.add(v);
            int alt = dist[current] +
                     g.get(current).children.get(i).second;
 
            // Condition to check the distance
            // is correct and update it
            // if it is minimum from the previous
            // computed distance
            if (alt < dist[v])
            {
                dist[v] = alt;
                path[v] = current;
            }
        }
        sett.remove(current);
         
        if (sett.isEmpty())
            break;
 
        // The new current
        int minDist = infi;
        int index = 0;
 
        // Loop to update the distance
        // of the vertices of the graph
        for(int a : sett)
        {
            if (dist[a] < minDist)
            {
                minDist = dist[a];
                index = a;
            }
        }
        current = index;
    }
    return dist;
}
 
// Function to print the path
// from the source vertex to
// the destination vertex
void printPath(int[] path, int i, int s)
{
    if (i != s)
    {
         
        // Condition to check if
        // there is no path between
        // the vertices
        if (path[i] == -1)
        {
            System.out.println("Path not found!!");
            return;
        }
        printPath(path, path[i], s);
        System.out.print(path[i] + " ");
    }
}
 
// Driver Code
public static void main(String[] args)
{
    List<Node> v = new ArrayList<>();
    int n = 4, s = 0, e = 5;
 
    // Loop to create the nodes
    for(int i = 0; i < n; i++)
    {
        Node a = new Node(i);
        v.add(a);
    }
 
    // Creating directed
    // weighted edges
    v.get(0).add_child(1, 1);
    v.get(0).add_child(2, 4);
    v.get(1).add_child(2, 2);
    v.get(1).add_child(3, 6);
    v.get(2).add_child(3, 3);
 
    int[] path = new int[v.size()];
    int[] dist = dijkstraDist(v, s, path);
 
    // Loop to print the distance of
    // every node from source vertex
    for(int i = 0; i < dist.length; i++)
    {
        if (dist[i] == infi)
        {
            System.out.printf("%d and %d are not " +
                              "connected\n", i, s);
            continue;
        }
        System.out.printf("Distance of %dth vertex " +
                          "from source vertex %d is: %d\n",
                          i, s, dist[i]);
    }
}
}
-----------------------------------------------------------------------------------------------

Algoritmo 2: Lista prioridade

// Java Program to Implement Dijkstra's Algorithm
// Using Priority Queue
  
// Importing utility classes
import java.util.*;
  
// Main class DPQ
public class GFG {
  
    // Member variables of this class
    private int dist[];
    private Set<Integer> settled;
    private PriorityQueue<Node> pq;
    // Number of vertices
    private int V;
    List<List<Node> > adj;
  
    // Constructor of this class
    public GFG(int V)
    {
  
        // This keyword refers to current object itself
        this.V = V;
        dist = new int[V];
        settled = new HashSet<Integer>();
        pq = new PriorityQueue<Node>(V, new Node());
    }
  
    // Method 1
    // Dijkstra's Algorithm
    public void dijkstra(List<List<Node> > adj, int src)
    {
        this.adj = adj;
  
        for (int i = 0; i < V; i++)
            dist[i] = Integer.MAX_VALUE;
  
        // Add source node to the priority queue
        pq.add(new Node(src, 0));
  
        // Distance to the source is 0
        dist[src] = 0;
  
        while (settled.size() != V) {
  
            // Terminating ondition check when
            // the priority queue is empty, return
            if (pq.isEmpty())
                return;
  
            // Removing the minimum distance node
            // from the priority queue
            int u = pq.remove().node;
  
            // Adding the node whose distance is
            // finalized
            if (settled.contains(u))
  
                // Continue keyword skips exwcution for
                // following check
                continue;
  
            // We don't have to call e_Neighbors(u)
            // if u is already present in the settled set.
            settled.add(u);
  
            e_Neighbours(u);
        }
    }
  
    // Method 2
    // To process all the neighbours
    // of the passed node
    private void e_Neighbours(int u)
    {
  
        int edgeDistance = -1;
        int newDistance = -1;
  
        // All the neighbors of v
        for (int i = 0; i < adj.get(u).size(); i++) {
            Node v = adj.get(u).get(i);
  
            // If current node hasn't already been processed
            if (!settled.contains(v.node)) {
                edgeDistance = v.cost;
                newDistance = dist[u] + edgeDistance;
  
                // If new distance is cheaper in cost
                if (newDistance < dist[v.node])
                    dist[v.node] = newDistance;
  
                // Add the current node to the queue
                pq.add(new Node(v.node, dist[v.node]));
            }
        }
    }
  
    // Main driver method
    public static void main(String arg[])
    {
  
        int V = 5;
        int source = 0;
  
        // Adjacency list representation of the
        // connected edges by declaring List class object
        // Declaring object of type List<Node>
        List<List<Node> > adj
            = new ArrayList<List<Node> >();
  
        // Initialize list for every node
        for (int i = 0; i < V; i++) {
            List<Node> item = new ArrayList<Node>();
            adj.add(item);
        }
  
        // Inputs for the GFG(dpq) graph
        adj.get(0).add(new Node(1, 9));
        adj.get(0).add(new Node(2, 6));
        adj.get(0).add(new Node(3, 5));
        adj.get(0).add(new Node(4, 3));
  
        adj.get(2).add(new Node(1, 2));
        adj.get(2).add(new Node(3, 4));
  
        // Calculating the single source shortest path
        GFG dpq = new GFG(V);
        dpq.dijkstra(adj, source);
  
        // Printing the shortest path to all the nodes
        // from the source node
        System.out.println("The shorted path from node :");
  
        for (int i = 0; i < dpq.dist.length; i++)
            System.out.println(source + " to " + i + " is "
                               + dpq.dist[i]);
    }
}
  
// Class 2
// Helper class implementing Comparator interface
// Representing a node in the graph
class Node implements Comparator<Node> {
  
    // Member variables of this class
    public int node;
    public int cost;
  
    // Constructors of this class
  
    // Constructor 1
    public Node() {}
  
    // Constructor 2
    public Node(int node, int cost)
    {
  
        // This keyword refers to current instance itself
        this.node = node;
        this.cost = cost;
    }
  
    // Method 1
    @Override public int compare(Node node1, Node node2)
    {
  
        if (node1.cost < node2.cost)
            return -1;
  
        if (node1.cost > node2.cost)
            return 1;
  
        return 0;
    }
}



